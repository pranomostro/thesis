% !TeX root = ../main.tex
% Add the above to each chapter to make compiling the PDF easier in some editors.

\chapter{Evaluation}\label{chapter:evaluation}

17 pages

\section{Research Questions}

\paragraph{Research Question 1: Does the Relative Effectiveness of the Different Algorithms Replicate the Results in \cite{cruciani2019scalable}?}

\subparagraph{Research Question 1.1: Does Their Relative Effectiveness in TSR Replicate the Findings
in \cite{cruciani2019scalable}?}

\subparagraph{Research Question 1.2: Does Their Relative Effectiveness in FDL Replicate the Findings in \cite{cruciani2019scalable}?}

\paragraph{Research Question 2: Does the Relative Runtime Performance of the Different Algorithms Replicate the Results in \cite{cruciani2019scalable}?}

\paragraph{Research Question 3: How Much Better Than Random Selection are Specialized Algorithms?}

\paragraph{(Possibly) Research Question 4: Do the Results in \cite{cruciani2019scalable} Replicate with the Original Test Data?}

\section{Study Design}

\section{Study Objects}

\section{Selecting Projects}

The code bases and test suites selected for this study were small to
medium sized open-source Java projects. They all used either JUnit
4 or JUnit 5 as their testing framework, and the tool Maven %CANDO: right capitalization?
for building and testing. We used the latest version.

The projects used, their versions and size are presented in table CANDO.

\begin{table}[htpb]
	\caption[]{}\label{tab:projects} %Project name, version, size of test suite, size of project, link to project
	\centering
	\begin{tabular}{l l l l l}
		\toprule
		Project name & Version (git commit) & Size of project (loc) & Size of test suite (loc) \\
		\midrule
		assertj-core & cb2829 & 135k & 241k \\
		commons-collections & 242918 & 59k & 45k \\
		commons-lang & 6b3f25 & 51k & 40k \\
		commons-math & 649b13 & 148k & 98k \\
		jopt-simple & 5a1d72 & 1.7k & 2.7k \\
		jsoup & 89580c & 18k & 12k \\
		\bottomrule
	\end{tabular}
\end{table}

\section{Study Setup}

Testing the performance of the algorithms required three different kinds
of information: the contents of the test suites, coverage information
and fault information.

\subsection{Combining Tests Suites}

For every examined project, the test suite was converted into a format
suitable for the code from \cite{cruciani2019scalable} by replacing the
newlines from each test with spaces and concatenating the tests into
one file (the \textbf{black-box file}), such that every line contained
one test case.

For some of the projects, test cases were excluded since they failed
during the default test run:

%CANDO: make second column multi-line

\begin{table}[htpb]
	\caption[]{}\label{tab:excluded} %Project name, excluded tests
	\centering
	\begin{tabular}{l l}
		\toprule
		Project name & Test classes excluded \\
		\midrule
		assertj-core & BDDSoftAssertionsTest, SoftAssertionsTest, SoftAssertions\_overriding\_afterAssertionErrorCollected\_Test, SoftAssertionsErrorsCollectedTest|SoftAssertionsMultipleProjectsTest, SoftAssertions\_setAfterAssertionErrorCollected\_Test, AssertJMultipleFailuresError\_getMessage\_Test \\
		commons-collections & BulkTest \\
		commons-lang & FieldUtilsTest \\
		commons-math & FastMathTest, EvaluationTestValidation \\
		jopt-simple & / \\
		jsoup & / \\
		\bottomrule
	\end{tabular}
\end{table}

\subsection{Generating Coverage Information}

Coverage information was generated using jacoco with the testwise mode
of the teamscale jacoco agent. %CANDO link

Since the teamscale jacoco agent only supports line coverage, other
types of coverage had to be eschewed.

%CANDO: add note about how line coverage subsumes branch & function coverage?

The json files created by the teamscale jacoco agent were converted
from JSON into the format used by \cite{cruciani2019scalable}: a file
containing a list of numbers in each line, with the numbers $n_1, \dots
n_i$ in line $n$ corresponding to the source lines of code in the tested
project covered by the test case at line $n$ in the \textbf{black-box
file}.

\subsection{Collecting Fault Coverage Information}

%Cite Budd TA. Mutation analysis of program test data

Fault detection information was not available for the projects used,
and was therefore generated by mutation testing using the mutation
testing framework pitest.

The generated mutation test data was converted from XML to the format used
in the code of \cite{cruciani2019scalable}: a text file containing a list
of number per line, the numbers at line $n$ corresponding to different
classes for which the test case at line $n$ in the \textbf{black-box file}
did find faults.

\section{Results}

\subsection{Research Questions}

\paragraph{Research Question 1.1}

\paragraph{Research Question 1.2}

\paragraph{Research Question 2}

\paragraph{Research Question 3}

\paragraph{(Possibly) Research Question 4}

\subsection{Running Time}

\section{Discussion}

Comparison to ''Scalable Approaches to Test Suite Reduction''

\section{Threats to Validity}

\subsection{Conclusion Validity}

\subsection{Internal Validity}

\subsection{Construct Validity}

\subsection{External Validity}
